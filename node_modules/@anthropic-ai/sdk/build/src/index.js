"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = exports.AI_PROMPT = exports.HUMAN_PROMPT = void 0;
const fetch_event_source_1 = require("@fortaine/fetch-event-source");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
exports.HUMAN_PROMPT = "\n\nHuman:";
exports.AI_PROMPT = "\n\nAssistant:";
const ANTHROPIC_SDK = "anthropic-typescript/0.4.4";
const ANTHROPIC_VERSION = "2023-01-01";
const DEFAULT_API_URL = "https://api.anthropic.com";
var Event;
(function (Event) {
    Event["Ping"] = "ping";
})(Event || (Event = {}));
const DONE_MESSAGE = "[DONE]";
class Client {
    constructor(apiKey, options) {
        var _a;
        this.apiKey = apiKey;
        this.apiUrl = (_a = options === null || options === void 0 ? void 0 : options.apiUrl) !== null && _a !== void 0 ? _a : DEFAULT_API_URL;
    }
    complete(params, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield (0, cross_fetch_1.default)(`${this.apiUrl}/v1/complete`, {
                method: "POST",
                headers: {
                    Accept: "application/json",
                    "Content-Type": "application/json",
                    "Anthropic-SDK": ANTHROPIC_SDK,
                    "Anthropic-Version": ANTHROPIC_VERSION,
                    "X-API-Key": this.apiKey,
                },
                body: JSON.stringify(Object.assign(Object.assign({}, params), { stream: false })),
                signal: options === null || options === void 0 ? void 0 : options.signal,
            });
            if (!response.ok) {
                const error = new Error(`Sampling error: ${response.status} ${response.statusText}`);
                console.error(error);
                throw error;
            }
            const completion = (yield response.json());
            return completion;
        });
    }
    completeStream(params, { onOpen, onUpdate, signal, }) {
        const abortController = new AbortController();
        return new Promise((resolve, reject) => {
            signal === null || signal === void 0 ? void 0 : signal.addEventListener("abort", (event) => {
                abortController.abort(event);
                reject({
                    name: "AbortError",
                    message: "Caller aborted completeStream",
                });
            });
            (0, fetch_event_source_1.fetchEventSource)(`${this.apiUrl}/v1/complete`, {
                method: "POST",
                headers: {
                    Accept: "application/json",
                    "Content-Type": "application/json",
                    "Anthropic-SDK": ANTHROPIC_SDK,
                    "Anthropic-Version": ANTHROPIC_VERSION,
                    "X-API-Key": this.apiKey,
                },
                body: JSON.stringify(Object.assign(Object.assign({}, params), { stream: true })),
                signal: abortController.signal,
                onopen: (response) => __awaiter(this, void 0, void 0, function* () {
                    if (!response.ok) {
                        abortController.abort();
                        return reject(Error(`Failed to open sampling stream, HTTP status code ${response.status}: ${response.statusText}`));
                    }
                    if (onOpen) {
                        yield Promise.resolve(onOpen(response));
                    }
                }),
                onmessage: (ev) => {
                    if (ev.event === Event.Ping) {
                        return;
                    }
                    if (ev.data === DONE_MESSAGE) {
                        console.error("Unexpected done message before stop_reason has been issued");
                        return;
                    }
                    const completion = JSON.parse(ev.data);
                    if (onUpdate) {
                        Promise.resolve(onUpdate(completion)).catch((error) => {
                            abortController.abort();
                            reject(error);
                        });
                    }
                    if (completion.stop_reason !== null) {
                        abortController.abort();
                        return resolve(completion);
                    }
                },
                onerror: (error) => {
                    console.error("Sampling error:", error);
                    abortController.abort();
                    return reject(error);
                },
            });
        });
    }
}
exports.Client = Client;
